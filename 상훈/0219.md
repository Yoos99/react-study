# 2025.02.19 / 3장 리액트 훅 깊게 살펴보기

## 3장 리액트 훅 깊게 살펴보기

**React Hook**이란 무엇이며, 왜 사용하나요? **_(rules-of-hooks // ESLint - react-hooks/rules-of-hooks)_**

- React Hook은 함수형 컴포넌트에서 React의 기능(상태 관리, 생명주기 메서드 등)을 사용할 수 있게 해주는 함수. 이전에는 클래스 컴포넌트에서만 상태와 생명주기를 관리할 수 있었지만, Hook을 통해 더 간결하고 유지보수하기 쉬운 코드 작성이 가능해짐 **(반드시 컴포넌트의 최상위 수준에서 호출해야 함!)**
- https://ko.legacy.reactjs.org/docs/hooks-rules.html
  - Hook은 호출 순서에 따라 React의 내부 상태를 관리. 조건문이나 반복문 내에서 호출하면 **호출 순서가 달라져** React의 상태 관리에 문제가 발생할 수 있음
  - 호출 순서가 달라지면 어떤 상태가 어떤 useState에서 호출되는지 알 수 없고 이로 인해 버그가 생긴다.
  위 내용을 **런타임에서 hook의 호출 순서가 동적으로 바뀌면 안된다.** 라고 이해
  또한, 훅을 호출할 수 있는 것은 리액트 함수 컴포넌트, 사용자 정의 훅 두 가지 경우. 일반 자스 함수 X

**useState의 게으른 초기화**

useState는 함수형 컴포넌트가 렌더링될 때 초기값을 설정
**함수를 전달**하면 컴포넌트가 처음 마운트될 때 한 번만 실행됨

```jsx
// 일반 초기화 -> 매 렌더링 시마다 heavyCalculation()이 호출
const [count, setCount] = useState(heavyCalculation());

// 게으른 초기화 -> 처음 렌더링 시에만 함수가 호출되어 성능 최적화가 가능
const [count, setCount] = useState(() => heavyCalculation());
```

**useEffect의 의존성 배열과 클린업 함수 사용 시 주의점**

**거대한 useEffect를 만들지 말자.**

- **useEffect**는 의존성 배열을 바탕으로 렌더링 시 의존성이 변경될 때마다 부수 효과를 실행함. 부수 효과가 커질 수록 성능에 악영향을 주기 때문에 가급적 가볍게 유지하는 편이 좋다.

React에서 성능 최적화를 위해 자주 사용되는 두 가지 Hook **useMemo, useCallback 차이**

useMemo는 **연산의 결과**를 메모이제이션하여 재계산을 방지하고,

useCallback은 **함수**(인수로 넘겨받은 콜백 자체)를 메모이제이션하여 동일한 함수 인스턴스를 유지

(자바스크립트에서는 함수 또한 값으로 표현될 수 있으므로 Memo로 Callback 구현은 가능하다고 함/복잡)

```jsx
const memoizedValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);
// 의존성 값 a와 b가 변경되지 않는 한 computeExpensiveValue 함수는 다시 호출되지 않음

const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
//의존성 값 a와 b가 변경되지 않는 한 doSomething 함수는 새로 생성되지 않음
```

그러나 2.5장에서 본 것처럼 useMemo와 useCallback을 사용할 때는 메모이제이션의 비용과 성능 최적화의 이점을 고려해야 한다.

왜냐하면 **메모이제이션 자체에도 비용이 발생**하기 때문

**useRef** 간단 설명

**DOM 요소에 접근**하거나 **렌더링과 관계없이** 값을 저장할 수 있는 Hook
**useRef**의 최초 기본값은 return 문에 정의해놓은 DOM이 아니라 **useRef()**로 넘겨받은 인수

렌더링을 발생시키지 않고 원하는 상태값을 저장할 수 있다는 특징을 활용해서 이전 값을 저장하는 **usePrevious()** 같은 훅을 구현할 때 유용

**useContext** 간단 설명

**전역 상태**를 계층 구조를 거치지 않고 **컴포넌트 간에 공유**할 수 있도록 한다.

### Context란?

![Image](https://github.com/user-attachments/assets/2ff8c30f-56fe-41a0-9084-e863eb3914f2)

- prop 내려주기(props drilling)을 극복하기 위해 나온 개념이 콘텍스트. 콘텍스트를 사용하면 `props` 전달 없이도 선언한 하위 컴포넌트 모두에서 원하는 값을 사용할 수 있다.

**useContext**는 상위 컴포넌트에서 만들어진 Context를 함수형 컴포넌트에서 사용할 수 있도록 만들어진 훅

주의점

- **useContext**를 함수형 컴포넌트 내부에서 사용해서 `Provider`에 대한 의존성을 가지게 되면 재활용하기 어려운 컴포넌트가 될 수 있다. 그렇다고 모든 콘텍스트를 최상위 루트 컴포넌트에 넣으면 에러는 줄어들 수 있지만 불필요한 리소스를 낭비. **따라서 필요한 환경에서 최대한 좁게 만들어야 한다.**
- **useContext**는 상태 관리 라이브러리가 아님. 엄밀히 말하면 상태를 주입하는 것

상태 관리 라이브러리가 되기 위해서는 최소 두 가지 조건이 만족해야 한다.

- 어떠한 상태를 기반으로 다른 상태를 만들어 낼 수 있어야 함
- 필요에 따라 이러한 상태 변화를 최적화할 수 있어야 함
- 콘텍스트는 **단순히 props를 하위로 전달해서 주입**할 뿐, 다른 상태를 만들어내거나 렌더링이 최적화되지는 않는다.

**useReducer**

**useReducer**는 **useState**의 심화 버전이라고 볼 수 있는데, 값이 아닌 `action`을 넘겨준다는 점에서 다름

**상태 변경 로직이 복잡**하거나 **상태를 하나의 객체로 관리**할 때 유용

- 반환값은 **useState**와 동일하게 2인 배열
  - state - 현재 useReducer가 갖고 있는 값입니다.
  - dispatcher - setState는 값을 넘겨주지만 action을 넘겨주는데, 이 action은 state를 변경할 수 있는 액션을 의미합니다.
- **useReducer**의 인수는 **useState**와 다르게 2개에서 3개가 필요
  - reducer - 기본 action을 정의하는 함수, useReducer의 첫 번째 인수입니다.
  - initialState - 두 번째 인수, useReducer의 초깃값입니다.
  - init - useState의 인수로 함수를 넘겨줄 때처럼 초깃값을 지연 생성하고자 할 때 사용하는 함수로 필수값은 아닙니다.

**useLayoutEffect**

**useEffect**와 동일하게 작동하지만, 실행 순서는 다르다. (**모든 DOM의 변경 후에 동기적으로 발생**)

순서상으로 먼저여도 항상 useLayoutEffect가 useEffect보다 먼저 실행됨.

1. 리액트가 DOM을 업데이트
2. `useLayoutEffect`를 실행
3. 브라우저에 변경사항을 반영
4. `useEffect`를 실행

동기적으로 발생한다는 건 리액트가 **useLayoutEffect**의 실행이 종료될 때까지 기다렸다가 화면을 그린다는 걸 의미. 따라서 웹 애플리케이션 성능 문제를 고려해서 사용할 필요가 있다.

_그럼 언제 사용하는 것이 좋다는 걸까?_
⇒ **DOM은 계산됐지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때**와 같이 반드시 필요할 때만 사용하는 것이 좋다. 특정 DOM요소를 기반으로 한 애니메이션, 스크롤 위치를 제어하는 등

더 자연스러운 사용자 경험을 제공할 수 있음.

## 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

**사용자 정의 훅(Custom Hook)이란?**

- 리액트에서 제공하는 훅(`useState`, `useEffect` 등)을 조합하여 **재사용 가능한 로직**을 추출한 함수
- **렌더링에 직접적인 영향을 주지 않는다.**

사용자 정의 훅 또한 앞서 언급한 리액트 훅의 규칙을 따라야 한다.

그리고 **react-hooks/rules-of-hooks**의 도움을 받기 위해서 **use**로 시작하는 이름도 가져야 한다.

**고차 컴포넌트(HOC)란?**

- 컴포넌트를 인수로 받아 **새로운 컴포넌트를 반환**하는 함수. 주로 컴포넌트의 로직을 재사용하거나, **렌더링 결과물에 영향을 주기 위해 사용**된다.
  사용자 정의 훅은 리액트 훅을 기반으로 하므로 리액트에서만 사용할 수 있는 기술이지만, 고차 컴포넌트는 리액트가 아니더라도 자바스크립트 환경에서 널리 쓰일 수 있다.
- 고차 컴포넌트 기법으로 다양한 최적화나 중복 로직 관리를 할 수 있는데, 그 대표적인 사례가 `React.memo`이다.

**React.memo란?**

→ 컴포넌트의 렌더링을 방지하기 위해 만들어진 리액트의 고차 컴포넌트이다.

- **컴포넌트를 메모이제이션**한다.
- **props가 변경되지 않으면** 컴포넌트를 다시 렌더링하지 않도록 최적화한다.
- **컴포넌트 외부**에서 사용된다.

컴포넌트도 값이라는 관점에서 본 것이라면 useMemo를 사용해서도 동일하게 가능한가?

→ useMemo는 값을 반환받기 때문에 JSX 함수 방식이 아닌 `{ }` 을 사용한 할당식을 사용해야 함.

구현은 가능하지만 혼란을 야기할 수 있으므로 목적과 용도가 뚜렷한 memo를 사용하자.

- 사용자 정의 훅이 `use`로 시작하는 이름을 사용했다면 리액트의 고차 컴포넌트도 마찬가지로 `with`로 시작하는 이름을 사용하는데, ESLint 규칙 등으로 강제하는 사항은 아니지만 일종의 관습으로 볼 수 있음

**사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?**

**사용자 정의 훅이 필요한 경우**

- 단순히 `useEffect`, `useState`와 같이 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있다면 사용자 정의 훅을 사용하는 것이 좋다. 그 자체로는 렌더링에 영향을 주지 못하기 때문에 반환하는 값을 바탕으로 컴포넌트 내부에 미치는 영향을 최소화해 훅을 원하는 방향으로만 사용할 수 있다는 장점이 있다. 부수 효과가 비교적 제한적이다. **⇒ 단순히 컴포넌트 전반에 걸쳐 동일한 로직으로 값을 제공하거나 특정한 훅의 작동을 취하게 하고 싶다면 사용자 정의 훅을 사용하는 것이 좋다.**

**고차 컴포넌트를 사용해야 하는 경우**

- 예컨대 로그인을 요구하는 컴포넌트의 경우 해당 컴포넌트를 감추고 로그인 컴포넌트를 노출하려 할 때 사용자 정의 훅만으로는 이를 표현하기가 어렵다. 해당 컴포넌트가 반환하는 렌더링 결과물에까지 영향을 미치기 어려울 뿐더러, 중복적으로 선언될 사용자 훅보다는 고차 컴포넌트를 사용해 처리하는 것이 좋다. ⇒ **함수 컴포넌트의 반환괎, 즉 렌더링의 결과물에도 영향을 미치는 공통 로직이라면 사용**
- 단, 고차 컴포넌트가 많아질수록 복잡성이 증가하기 때문에 신중하게 사용해야 한다.
