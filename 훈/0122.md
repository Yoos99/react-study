## 01장 리액트 개발을 위해 꼭 알아야 할 자바스크립트

### 자바스크립트의 동등 비교

JS의 데이터 타입

원시타입(primitive type) - 객체가 아닌 모든 다른 타입
- boolean
- null
- undefined
- number
- string
- symbol
- bigint

객체타입(object/reference type)
- object (배열, 함수, 정규식, 클래스 등)

> 값을 저장하는 방식에 차이가 있음
> 원시타입 - 불변값, 메모리에 저장(변수 할당 시점에)
> 객체타입 - 가변값, 참조를 저장

##### Object.is

ES6에 새로 도입된 비교 문법
두 개의 인수를 받아 동일한지 확인하고 반환

`==` 혹은 `===` 가 판단하지 못하는 몇 가지 특이 케이스를 판단 가능

```
2 == "2" // true
Object.is(2, "2") // false

-0 === +0 // true
Object.is(-0, +0) // false

Number.NAN === NAN // false
Object.is(Number.NAN, NAN) // true
```

> 여전히 객체 간 비교에서는 `===`과 동일하게 동작

#### 리액트에서의 동등 비교

리액트에서는 `==`, `===`이 아닌 Object.is를 사용
Object.is를 기반으로 하는 shallowEqual이라는 함수를 만들어 사용
Object.is로 먼저 비교를 수행한 후, 객체 간 얕은 비교를 한번 더 수행하는 방식

---

### 함수

> 호이스팅 - 선언한 변수 혹은 함수가 코드 최상단으로 올라오는 것을 의미
> 변수의 호이스팅
> var - 선언 후 `undefined`값으로 초기화되며 호이스팅됨
> let, const - 호이스팅은 되지만 TDZ존에 있어 선언한 코드 줄 이전에는 참조오류 발생

JS에서 함수를 정의하는 4가지 방법

1. 함수 선언문 - 함수 호이스팅 발생
2. 함수 표현식 - 변수 호이스팅 발생
3. Function 생성자 - 권장X
4. 화살표 함수

#### 화살표 함수
ES6에서 추가된 함수 생성 방식. 항상 익명
`function`키워드 대신 `=>` 사용 ( 더 간결)
- 생성자 함수로 사용할 수 X(constructor 사용할 수 없음)
- arguments 존재 X
- 함수 자체의 바인딩을 갖지 않고, this를 참조할 시 상위 스코프의 this를 가져옴

---

## 클로저

함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합
-> 함수가 생성될 때의 환경(스코프) 정보를 기억하고, 그 환경에 접근할 수 있는 함수

> 렉시컬 스코프: 함수를 선언할 때의 스코프가 함수 실행과 관계없이 유지되는 것
> 전역 스코프: 전역 레벨에 선언된 변수는 어디서든 접근 가능
> 함수 스코프: 함수 내부에서 선언된 변수는 **해당 함수 내에서만 접근 가능**하며, 함수 호출이 끝나면 제거됨

```js
function outer() {
  var a = 2;
  function inner() {
    console.log(a);
  }
  return inner;
}
var func = outer();
func(); // 2
```

##### 클로저의 특징
- 외부 함수의 변수를 내부 함수에서 기억하고 사용할 수 있음
- 전역 스코프의 사용을 줄이고 특정 데이터만 노출 가능
- 함수가 실행된 후에도 변수 값이 유지되므로, 여러 번 호출할 때 상태를 지속적으로 관리 가능

##### 클로저의 활용
- 데이터 은닉(Encapsulation): 외부에서 직접 접근할 수 없고, 특정 함수만 데이터를 조작할 수 있도록 함.
- 상태 유지(State Persistence): 함수 실행 후에도 데이터를 유지하여 연속적인 연산 가능.
- 이벤트 핸들러: 비동기 함수에서 특정 값을 지속적으로 유지하는 데 사용됨.

##### 클로저 사용 시 주의할 점
- 메모리 누수 가능성
- 참조 문제 발생 가능