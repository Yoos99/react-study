# 리액트의 모든 훅 파헤치기

## 1. useState

상태(state)를 선언하고 관리하는 기본 훅

```jsx
const [count, setCount] = useState(0);
setCount(count + 1);
```

- 초기값을 인자로 받음
- setState 함수를 사용하여 상태 업데이트
- 컴포넌트가 다시 렌더링됨

## 2. useEffect

부수 효과(side effect) 실행을 위한 훅 (API 요청, 이벤트 리스너 추가 등)

```jsx
useEffect(() => {
  console.log('컴포넌트가 마운트됨!');
  return () => console.log('컴포넌트가 언마운트됨!'); // Cleanup 함수
}, []);
```

- 두 번째 인자로 의존성 배열을 받음
- [] → 마운트 시 1회 실행
- [state] → state가 변경될 때 실행
- 없을 경우 매 렌더링마다 실행

## 3. useMemo

비싼 연산을 메모이제이션하여 불필요한 재연산 방지

```jsx
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(data);
}, [data]);
```

- data가 변경될 때만 다시 계산
- 불필요한 연산을 줄여 성능 최적화

## 4. useCallback

함수를 메모이제이션하여 불필요한 렌더링 방지

```jsx
const handleClick = useCallback(() => {
  console.log('Button clicked!');
}, []);
```

- useMemo와 유사하지만 함수 자체를 메모이제이션
- 의존성이 변경되지 않는 한 같은 함수 객체 유지

## 5. useRef

DOM 요소나 값을 유지하지만 렌더링을 발생시키지 않음

```jsx
const inputRef = useRef(null);
<input ref={inputRef} />;
```

- .current 프로퍼티를 통해 접근 가능
- inputRef.current.focus()와 같이 직접 조작 가능

## 6. useContext

전역 상태를 쉽게 공유할 수 있도록 도와주는 훅

```jsx
const ThemeContext = createContext('light');
const theme = useContext(ThemeContext);
```

- Provider에서 값을 제공하고 Consumer(또는 useContext)에서 사용
- props drilling 없이 상태 공유 가능

## 7. useReducer

복잡한 상태 관리를 위한 훅 (Redux와 비슷)

```jsx
const reducer = (state, action) => {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    default:
      return state;
  }
};
const [state, dispatch] = useReducer(reducer, { count: 0 });
dispatch({ type: 'increment' });
```

- useState보다 복잡한 상태 로직을 관리할 때 사용
- state와 dispatch를 반환하며, dispatch로 액션을 전달
